-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2010 Altera Corporation
-- Your use of Altera Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Altera Program License
-- Subscription Agreement, Altera MegaCore Function License
-- Agreement, or other applicable license agreement, including,
-- without limitation, that your use is for the sole purpose of
-- programming logic devices manufactured by Altera and sold by
-- Altera or its authorized distributors.  Please refer to the
-- applicable agreement for further details.


-- Generated by Quartus II Version 9.1 (Build Build 350 03/24/2010)
-- Created on Sat Jan 15 11:06:17 2011
INCLUDE "lpm_bustri_WORD.inc";
INCLUDE "Video/BLITTER/lpm_clshift384.inc";
INCLUDE "Video/BLITTER/altsyncram0.inc";
INCLUDE "Video/BLITTER/lpm_clshift144.inc";
INCLUDE "Video/BLITTER/lpm_ror128.inc";


--CONSTANT  BL_SKEW_LF = 255;

--  Title Statement (optional)
TITLE "Blitter";


--  Parameters Statement (optional)

-- {{ALTERA_PARAMETERS_BEGIN}} DO NOT REMOVE THIS LINE!
-- {{ALTERA_PARAMETERS_END}} DO NOT REMOVE THIS LINE!


--  Subdesign Section

SUBDESIGN BLITTER
(
    -- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
    nRSTO : INPUT;
    MAIN_CLK : INPUT;
    FB_ALE : INPUT;
    nFB_WR : INPUT;
    nFB_OE : INPUT;
    FB_SIZE0 : INPUT;
    FB_SIZE1 : INPUT;
    VIDEO_RAM_CTR[15..0] : INPUT;
    BLITTER_ON : INPUT;
    FB_ADR[31..0] : INPUT;
    nFB_CS1 : INPUT;
    nFB_CS2 : INPUT;
    nFB_CS3 : INPUT;
    DDRCLK0 : INPUT;
    VDP_IN[63..0] : INPUT;
    BLITTER_DACK[4..0] : INPUT;
    SR_BLITTER_DACK : INPUT;
    BLITTER_RUN : OUTPUT;
    BLITTER_INT : OUTPUT;
    BLITTER_DOUT[127..0] : OUTPUT;
    BLITTER_ADR[31..0] : OUTPUT;
    BLITTER_SIG : OUTPUT;
    BLITTER_WR : OUTPUT;
    BLITTER_TA : OUTPUT;
    FB_AD[31..0] : BIDIR;
    -- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
)

VARIABLE
    BYT                         :NODE;
    FB_16B[1..0]                :NODE;
    BLITTER_CS                  :NODE;
    BL_HRAM_CS                  :NODE;
    DP_RAM_CS                   :NODE;
    BL_HRAM_BE[1..0]            :NODE;
    BL_HRAM_OUT[15..0]          :NODE;
    BL_DPRAM_OUT[15..0]         :NODE;
    BL_SRC_X_INC_CS             :NODE;
    BL_SRC_X_INC[15..0]         :DFFE;
    SRC_ADR_INC[31..0]          :NODE;
    SRC_XINC32[31..0]           :NODE;
    BL_SRC_Y_INC_CS             :NODE;
    BL_SRC_Y_INC[15..0]         :DFFE;
    SRC_YINC32[31..0]           :NODE;
    BL_ENDMASK1_CS              :NODE;
    BL_ENDMASK1[15..0]          :DFFE;
    BL_ENDMASK2_CS              :NODE;
    BL_ENDMASK2[15..0]          :DFFE;
    BL_ENDMASK3_CS              :NODE;
    BL_ENDMASK3[15..0]          :DFFE;
    BL_ENDMASK0[15..0]          :NODE;
    BL_ENDMASKF[15..0]          :NODE;
    BL_ENDMASKL[15..0]          :NODE;
    BL_ENDMASKR[15..0]          :NODE;
    BL_SRC_ADRH_CS              :NODE;
    BL_SRC_ADRL_CS              :NODE;
    BL_SRC_ADR[31..0]           :DFFE;
    SRC_OLD[27..0]              :DFFE;
    SRC_IADRH_CS                :NODE;
    SRC_IADRL_CS                :NODE;
    SRC_IADR[31..0]             :DFF;
    SRC_IADR_CLR                :DFF;
    SRC_ADR32[31..0]            :NODE;
    BL_DST_X_INC_CS             :NODE;
    BL_DST_X_INC[15..0]         :DFFE;
    DST_ADR_INC[31..0]          :NODE;
    DST_XINC32[31..0]           :NODE;
    BL_DST_Y_INC_CS             :NODE;
    BL_DST_Y_INC[15..0]         :DFFE;
    DST_YINC32[31..0]           :NODE;
    BL_DST_ADRH_CS              :NODE;
    BL_DST_ADRL_CS              :NODE;
    BL_DST_ADR[31..0]           :DFFE;
    DST_IADRH_CS                :NODE;
    DST_IADRL_CS                :NODE;
    DST_IADR[31..0]             :DFF;
    DST_IADR_CLR                :DFF;
    DST_ADR32[31..0]            :NODE;
    BL_X_CNT_CS                 :NODE;
    BL_X_CNT[15..0]             :DFFE;
    X_CNT16[15..0]              :NODE;
    BL_Y_CNT_CS                 :NODE;
    BL_Y_CNT[15..0]             :DFFE;
    BL_HOP_CS                   :NODE;
    BL_HOP[7..0]                :DFFE;
    BL_OP[7..0]                 :DFFE;
    BL_LN_CS                    :NODE;
    BL_LN_WR                    :NODE;
    LN7_CLR                     :NODE;
    BL_LN[7..0]                 :DFFE;
    BL_SKEW[7..0]               :DFFE;
-- barell shifter
    DIST_RIGHT[8..0]            :NODE;
    BS_SKEW[7..0]               :NODE;
    BL_BSIN[383..0]             :NODE;
    BL_BSOUT[383..0]            :NODE;
    SHIFT_DIR                   :NODE;
    BL_SRC_BUF1[127..0]         :DFFE;
    BL_SRC_BUF2[127..0]         :DFFE;
    BL_SRC_BUF3[127..0]         :DFFE;
    BL_DST_BUFRD[127..0]        :DFFE;
    BL_READ_DST                 :NODE;              -- LATCH SIGNAL DST BUF RD
    BL_READ_SRC                 :NODE;              -- LATCH SIGNAL SRC BUF
    SRC_READ                    :NODE;              -- FREIGABE LATCH SIGNAL
    NOT_DST_READ                :NODE;
    WREN_B                      :NODE;              -- WR ENA HALFTONE RAM
    X_INDEX_CS                  :NODE;
    X_INDEX[15..0]              :DFF;               -- LAUFZEIGER X COUNT
    X_INDEX_CLR                 :DFF;               -- X INDEX L�SCHEN CPU WRITE
    X_INDEX_CLR_DIR             :NODE;              -- X INDEX L�SCHEN STATE MACHINE
    DST_X_INC[15..0]            :NODE;              -- ANZAHL WORTE PRO DURCHLAUF
    X_CNT_T[15..0]              :NODE;
    Y_INDEX_CS                  :NODE;
    Y_INDEX[15..0]              :DFF;               -- LAUFZEIGER Y COUNT
    Y_INDEX_CLR                 :DFF;
    LINE_NR[3..0]               :NODE;
    SDXINC                      :DFF;               -- INC INDEX SPALTE
    YIINC                       :NODE;              -- INC INDEX ZEILE
    ZAINC                       :NODE;              -- INC ADRESSEN ZEILENUMBRUCH
    HOP_OUT[127..0]             :NODE;
    OP_OUT[127..0]              :NODE;
    ENDMASK1_SHIFT[7..0]        :NODE;
    ENDMASK2_SHIFT[7..0]        :NODE;
    ENDMASK12_IN[143..0]        :NODE;
    ENDMASK12_OUT[143..0]       :NODE;
    ENDMASK23_IN[143..0]        :NODE;
    ENDMASK23_OUT[143..0]       :NODE;
    ENDMASKM_IN[127..0]         :NODE;
    ENDMASKM_OUT[127..0]        :NODE;
    ROR_CNT[8..0]               :NODE;
    ENDMASK123[127..0]          :DFF;
    ENDMASKEND[31..0]           :NODE;
    BLITTER_SIG                 :DFF;
    BLITTER_REQ                 :NODE;
    BL_START                    :DFF;
    BL_NOTRUN                   :NODE;

-- MAIN STATE MACHINE
    BL_SM                       :MACHINE WITH STATES(START,NEW_LINE,RDSRC3,RDSRC2,RDSRC1,RDDST,WRDSTW,WRDST,TESTZEILENENDE,TESTFERTIG,FERTIG);

BEGIN
-- BYT UND WORD SELECT 16 BIT
    BYT      = !FB_SIZE1 &  FB_SIZE0;
    FB_16B0 = FB_ADR[0]==0;                                     -- wenn ADR==0
    FB_16B1 = FB_ADR[0]==1 # !BYT;                              -- wenn ADR==1 or NOT BYT
-- BLITTER CS
    BLITTER_CS = !nFB_CS1 & FB_ADR[19..7]==H"1F14";             -- FFFF8A00-7F
    BLITTER_TA = BLITTER_CS;
-- REGISTER
    -- HALFTON RAM
    BL_HRAM_CS = !nFB_CS1 & FB_ADR[19..5]==H"7C50";                     -- $F8A00-1F.w
    BL_HRAM_BE1 = BL_HRAM_CS & FB_16B0;
    BL_HRAM_BE0 = BL_HRAM_CS & FB_16B1;
    WREN_B = B"0";
    LINE_NR[] = BL_LN[3..0] + ((Y_INDEX[3..0] & !BL_DST_X_INC15) - (Y_INDEX[3..0] & BL_DST_X_INC15));
    (BL_DPRAM_OUT[],BL_HRAM_OUT[]) = altsyncram0(FB_ADR[4..1],LINE_NR[],BL_HRAM_BE[],MAIN_CLK,DDRCLK0,FB_AD[31..16],FB_AD[31..16],BL_HRAM_CS & !nFB_WR,WREN_B);
    DP_RAM_CS = !nFB_CS1 & FB_ADR[19..1]==H"7C528";                         -- $F8A50.w
    -- SRC X INC
    BL_SRC_X_INC[].CLK = MAIN_CLK;
    BL_SRC_X_INC[15..1] = FB_AD[31..17];
    BL_SRC_X_INC0 = GND;
    BL_SRC_X_INC_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C510");                       -- $F8A20.w
    BL_SRC_X_INC[15..8].ENA = BL_SRC_X_INC_CS & !nFB_WR & FB_16B0;
    BL_SRC_X_INC[7..0].ENA  = BL_SRC_X_INC_CS & !nFB_WR & FB_16B1;
    SRC_XINC32[15..0]  = BL_SRC_X_INC[];                                            -- ERWEITERN AUF 32 BIT
    SRC_XINC32[31..16] = H"FFFF" & BL_SRC_X_INC15;                                  -- ERWEITERN AUF 32 BIT
    -- SRC Y INC
    BL_SRC_Y_INC[].CLK = MAIN_CLK;
    BL_SRC_Y_INC[15..1] = FB_AD[31..17];
    BL_SRC_Y_INC0 = GND;
    BL_SRC_Y_INC_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C511");                       -- $F8A22.w
    BL_SRC_Y_INC[15..8].ENA = BL_SRC_Y_INC_CS & !nFB_WR & FB_16B0;
    BL_SRC_Y_INC[7..0].ENA  = BL_SRC_Y_INC_CS & !nFB_WR & FB_16B1;
    SRC_YINC32[15..0]  = BL_SRC_Y_INC[];                                            -- ERWEITERN AUF 32 BIT
    SRC_YINC32[31..16] = H"FFFF" & BL_SRC_Y_INC15;                                  -- ERWEITERN AUF 32 BIT
    -- SRC ADR HIGH
    BL_SRC_ADR[].CLK = MAIN_CLK;
    BL_SRC_ADR[31..16] = FB_AD[31..16];
    BL_SRC_ADRH_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C512");                        -- $F8A24.w
    BL_SRC_ADR[31..24].ENA = BL_SRC_ADRH_CS & !nFB_WR & FB_16B0;
    BL_SRC_ADR[23..16].ENA = BL_SRC_ADRH_CS & !nFB_WR & FB_16B1;
    -- SRC ADR LOW
    BL_SRC_ADR[].CLK = MAIN_CLK;
    BL_SRC_ADR[15..1] = FB_AD[31..17];
    BL_SRC_ADR0 = GND;
    BL_SRC_ADRL_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C513");                        -- $F8A26.w
    BL_SRC_ADR[15..8].ENA = BL_SRC_ADRL_CS & !nFB_WR & FB_16B0;
    BL_SRC_ADR[7..0].ENA  = BL_SRC_ADRL_CS & !nFB_WR & FB_16B1;
    SRC_IADR[].CLK = DDRCLK0;
    SRC_IADRH_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C520");                          -- $F8A40.w
    SRC_IADRL_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C521");                          -- $F8A42.w
    SRC_IADR_CLR.CLK = MAIN_CLK;
    SRC_IADR_CLR = (BL_SRC_ADRL_CS # BL_SRC_ADRH_CS) & !nFB_WR;             -- L�SCHEN BEI WRITE
    SRC_IADR[] = (((SRC_IADR[] + (SRC_ADR_INC[] & SDXINC)) & !ZAINC) + ((((((0,BL_X_CNT[]) - 1) * SRC_XINC32[]) + SRC_YINC32[]) * (0,Y_INDEX[])) & ZAINC)) & SRC_READ & !SRC_IADR_CLR;
    SRC_ADR32[] = BL_SRC_ADR[] + SRC_IADR[];                            -- ZUGRIFFSADRESSE THEORETISCH
    -- ENDMASK 1
    BL_ENDMASK1[].CLK = MAIN_CLK;
    BL_ENDMASK1[] = FB_AD[31..16];
    BL_ENDMASK1_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C514");                        -- $F8A28.w
    BL_ENDMASK1[15..8].ENA = BL_ENDMASK1_CS & !nFB_WR & FB_16B0;
    BL_ENDMASK1[7..0].ENA  = BL_ENDMASK1_CS & !nFB_WR & FB_16B1;
    -- ENDMASK 2
    BL_ENDMASK2[].CLK = MAIN_CLK;
    BL_ENDMASK2[] = FB_AD[31..16];
    BL_ENDMASK2_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C515");                        -- $F8A2A.w
    BL_ENDMASK2[15..8].ENA = BL_ENDMASK2_CS & !nFB_WR & FB_16B0;
    BL_ENDMASK2[7..0].ENA  = BL_ENDMASK2_CS & !nFB_WR & FB_16B1;
    -- ENDMASK 3
    BL_ENDMASK3[].CLK = MAIN_CLK;
    BL_ENDMASK3[] = FB_AD[31..16];
    BL_ENDMASK3_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C516");                        -- $F8A2C.w
    BL_ENDMASK3[15..8].ENA = BL_ENDMASK3_CS & !nFB_WR & FB_16B0;
    BL_ENDMASK3[7..0].ENA  = BL_ENDMASK3_CS & !nFB_WR & FB_16B1;
    -- DST X INC
    BL_DST_X_INC[].CLK = MAIN_CLK;
    BL_DST_X_INC[15..1] = FB_AD[31..17];
    BL_DST_X_INC0 = GND;
    BL_DST_X_INC_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C517");                       -- $F8A2E.w
    BL_DST_X_INC[15..8].ENA = BL_DST_X_INC_CS & !nFB_WR & FB_16B0;
    BL_DST_X_INC[7..0].ENA  = BL_DST_X_INC_CS & !nFB_WR & FB_16B1;
    DST_XINC32[15..0]  = BL_DST_X_INC[];                                            -- ERWEITERN AUF 32 BIT
    DST_XINC32[31..16] = H"FFFF" & BL_DST_X_INC15;                                  -- ERWEITERN AUF 32 BIT
    -- DST Y INC
    BL_DST_Y_INC[].CLK = MAIN_CLK;
    BL_DST_Y_INC[15..1] = FB_AD[31..17];
    BL_DST_Y_INC0 = GND;
    BL_DST_Y_INC_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C518");                       -- $F8A30.w
    BL_DST_Y_INC[15..8].ENA = BL_DST_Y_INC_CS & !nFB_WR & FB_16B0;
    BL_DST_Y_INC[7..0].ENA  = BL_DST_Y_INC_CS & !nFB_WR & FB_16B1;
    DST_YINC32[15..0]  = BL_DST_Y_INC[];                                            -- ERWEITERN AUF 32 BIT
    DST_YINC32[31..16] = H"FFFF" & BL_DST_Y_INC15;                                  -- ERWEITERN AUF 32 BIT
    -- DST ADR HIGH
    BL_DST_ADR[].CLK = MAIN_CLK;
    BL_DST_ADR[31..16] = FB_AD[31..16];
    BL_DST_ADRH_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C519");                        -- $F8A32.w
    BL_DST_ADR[31..24].ENA = BL_DST_ADRH_CS & !nFB_WR & FB_16B0;
    BL_DST_ADR[23..16].ENA = BL_DST_ADRH_CS & !nFB_WR & FB_16B1;
    -- DST ADR LOW
    BL_DST_ADR[].CLK = MAIN_CLK;
    BL_DST_ADR[15..1] = FB_AD[31..17];
    BL_DST_ADR0 = GND;
    BL_DST_ADRL_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C51A");                        -- $F8A34.w
    BL_DST_ADR[15..8].ENA = BL_DST_ADRL_CS & !nFB_WR & FB_16B0;
    BL_DST_ADR[7..0].ENA  = BL_DST_ADRL_CS & !nFB_WR & FB_16B1;
    DST_IADR[].CLK = DDRCLK0;
    DST_IADRH_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C522");                          -- $F8A44.w
    DST_IADRL_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C523");                          -- $F8A46.w
    DST_IADR_CLR.CLK = MAIN_CLK;
    DST_IADR_CLR = (BL_DST_ADRL_CS # BL_DST_ADRH_CS) & !nFB_WR;                 -- L�SCHEN BEI WRITE
    DST_IADR[] = (((DST_IADR[] + (DST_ADR_INC[] & SDXINC)) & !ZAINC) + ((((((0,BL_X_CNT[]) - 1) * DST_XINC32[]) + DST_YINC32[]) * (0,Y_INDEX[])) & ZAINC)) & !DST_IADR_CLR;
    DST_ADR32[] = BL_DST_ADR[] + DST_IADR[];                                    -- ZUGRIFFSADRESSE THEORETISCH
    -- X COUNT
    BL_X_CNT[].CLK = MAIN_CLK;
    BL_X_CNT[] = FB_AD[31..16];
    BL_X_CNT_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C51B");                           -- $F8A36.w
    BL_X_CNT[15..8].ENA = BL_X_CNT_CS & !nFB_WR & FB_16B0;
    BL_X_CNT[7..0].ENA  = BL_X_CNT_CS & !nFB_WR & FB_16B1;
    X_INDEX[].CLK = DDRCLK0;
    X_INDEX_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C524");                            -- $F8A48.w
    X_INDEX_CLR.CLK = MAIN_CLK;
    X_INDEX_CLR = BL_X_CNT_CS & !nFB_WR;                                        -- L�SCHEN BEI WRITE
    X_INDEX[] = ((X_INDEX[] & !ZAINC) + (DST_X_INC[] & SDXINC) + (BL_X_CNT[] & ZAINC)) & !X_INDEX_CLR & !X_INDEX_CLR_DIR;
    X_CNT16[] = X_INDEX[] - (X_CNT_T[] & (X_INDEX[]!=0));       -- EFFEKTIV geschrieben
-- SCHRITTWEITEN BEI PALLETTENMOD
    IF (BL_SRC_X_INC[] != BL_DST_X_INC[]) # (BL_X_CNT[] < 4) THEN
        DST_X_INC[] = 1;
        X_CNT_T[] = 0;
        SRC_ADR_INC[] = SRC_XINC32[];       -- SRC X INC
        DST_ADR_INC[] = DST_XINC32[];       -- DST X INC
    ELSE
        IF BL_SRC_X_INC[] == H"0002" THEN
            DST_X_INC[] = 8;
            X_CNT_T[] = (0,DST_ADR32[3..1]);
            SRC_ADR_INC[] = 16;                     -- SRC X INC
            DST_ADR_INC[] = 16;                     -- DST X INC
        ELSE
            IF BL_SRC_X_INC[] == H"FFFE" THEN
                DST_X_INC[] = 8;
                X_CNT_T[] = 7 - (0,DST_ADR32[3..1]);
                SRC_ADR_INC[] = -16;                -- SRC X INC
                DST_ADR_INC[] = -16;                -- DST X INC
            ELSE
                IF BL_SRC_X_INC[] == H"0004" THEN
                    DST_X_INC[] = 4;
                    X_CNT_T[] = (0,DST_ADR32[3..2]);
                    SRC_ADR_INC[] = 16;                     -- SRC X INC
                    DST_ADR_INC[] = 16;                     -- DST X INC
                ELSE
                    IF BL_SRC_X_INC[] == H"FFFC" THEN
                        DST_X_INC[] = 4;
                        X_CNT_T[] = 3 - (0,DST_ADR32[3..2]);
                        SRC_ADR_INC[] = -16;                -- SRC X INC
                        DST_ADR_INC[] = -16;                -- DST X INC
                    ELSE
                        IF BL_SRC_X_INC[] == H"0008" THEN
                            DST_X_INC[] = 2;
                            X_CNT_T[] = (0,DST_ADR32[3]);
                            SRC_ADR_INC[] = 16;                     -- SRC X INC
                            DST_ADR_INC[] = 16;                     -- DST X INC
                        ELSE
                            IF BL_SRC_X_INC[] == H"FFF8" THEN
                                DST_X_INC[] = 2;
                                X_CNT_T[] = 1 - (0,DST_ADR32[3]);
                                SRC_ADR_INC[] = -16;                -- SRC X INC
                                DST_ADR_INC[] = -16;                -- DST X INC
                            ELSE
                                DST_X_INC[] = 1;
                                X_CNT_T[] = 0;
                                SRC_ADR_INC[] = SRC_XINC32[];       -- SRC X INC
                                DST_ADR_INC[] = DST_XINC32[];       -- DST X INC
                            END IF;
                        END IF;
                    END IF;
                END IF;
            END IF;
        END IF;
    END IF;
    -- Y COUNT
    BL_Y_CNT[].CLK = MAIN_CLK;
    BL_Y_CNT[] = FB_AD[31..16];
    BL_Y_CNT_CS = !nFB_CS1 & FB_ADR[19..1]==H"7C51C";                           -- $F8A38.w
    BL_Y_CNT[15..8].ENA = BL_Y_CNT_CS & !nFB_WR & FB_16B0;
    BL_Y_CNT[7..0].ENA  = BL_Y_CNT_CS & !nFB_WR & FB_16B1;
    Y_INDEX[].CLK = DDRCLK0;
    Y_INDEX_CS = !nFB_CS1 & FB_ADR[19..1]==H"7C525";                            -- $F8A4A.w
    Y_INDEX_CLR.CLK = MAIN_CLK;
    Y_INDEX_CLR = BL_Y_CNT_CS & !nFB_WR;                                        -- L�SCHEN BEI WRITE
    Y_INDEX[] = (Y_INDEX[] + (1 & YIINC)) & !Y_INDEX_CLR;
    -- HOP LOGIC
    BL_HOP[].CLK = MAIN_CLK;
    BL_HOP[] = FB_AD[31..24];
    BL_HOP_CS = !nFB_CS1 & FB_ADR[19..1]==H"7C51D";                             -- $F8A3A.w
    BL_HOP[7..0].ENA  = BL_HOP_CS & !nFB_WR & FB_16B0;                          -- $F8A3A
    -- OP LOGIC
    BL_OP[].CLK = MAIN_CLK;
    BL_OP[] = FB_AD[23..16];
    BL_OP[7..0].ENA  = BL_HOP_CS & !nFB_WR & FB_16B1;                           -- $F8A3B
    -- LINE NUMBER BYT
    BL_LN[].CLK = MAIN_CLK;
    BL_LN_CS = !nFB_CS1 & (FB_ADR[19..1] == H"7C51E");                          -- $F8A3C.w
    BL_LN_WR = BL_LN_CS & !nFB_WR & FB_16B0;                                    -- $F8A3C WRITE SIGNAL
    BL_LN[6..0] = FB_AD[30..24];                                                -- HOG UND SMUDGE
    BL_LN[6..0].ENA  = BL_LN_WR;                                                    -- $F8A3C
    BL_LN7.ENA  = BL_LN_WR # LN7_CLR;                                                   -- $F8A3C
    BL_LN7 = FB_AD31 & BLITTER_ON & (BL_X_CNT[] > X_CNT16[]) & (BL_Y_CNT[] > Y_INDEX[]) & !LN7_CLR; -- BUSY
    BL_START.CLK = MAIN_CLK;
    BL_START = BL_LN7 & !BL_LN_CS & BLITTER_ON & (BL_X_CNT[] > X_CNT16[]) & (BL_Y_CNT[] > Y_INDEX[]) & !LN7_CLR;
    -- SKEW BYT
    BL_SKEW[].CLK = MAIN_CLK;
    BL_SKEW[] = FB_AD[23..16];
    BL_SKEW[].ENA  = BL_LN_CS & !nFB_WR & FB_16B1;                              -- $F8A3D
--- REGISTER OUT
    FB_AD[31..16] = lpm_bustri_WORD(
                        BL_HRAM_CS      & BL_DPRAM_OUT[]
                      # BL_SRC_X_INC_CS & BL_SRC_X_INC[]
                      # BL_SRC_Y_INC_CS & BL_SRC_Y_INC[]
                      # BL_SRC_ADRH_CS  & SRC_ADR32[31..16]
                      # BL_SRC_ADRL_CS  & SRC_ADR32[15..0]
                      # BL_ENDMASK1_CS  & BL_ENDMASK1[]
                      # BL_ENDMASK2_CS  & BL_ENDMASK2[]
                      # BL_ENDMASK3_CS  & BL_ENDMASK3[]
                      # BL_DST_X_INC_CS & BL_DST_X_INC[]
                      # BL_DST_Y_INC_CS & BL_DST_Y_INC[]
                      # BL_DST_ADRH_CS  & DST_ADR32[31..16]
                      # BL_DST_ADRL_CS  & DST_ADR32[15..0]
                      # BL_X_CNT_CS     & (BL_X_CNT[]-X_INDEX[])
                      # BL_Y_CNT_CS     & (BL_Y_CNT[]-Y_INDEX[])
                      # BL_HOP_CS       & (BL_HOP[],BL_OP[])
                      # BL_LN_CS        & (BL_LN7 # !BL_NOTRUN,BL_LN[6..0],BL_SKEW[])
                      # SRC_IADRH_CS    & SRC_IADR[31..16]
                      # SRC_IADRL_CS    & SRC_IADR[15..0]
                      # DST_IADRH_CS    & DST_IADR[31..16]
                      # DST_IADRL_CS    & DST_IADR[15..0]
                      # X_INDEX_CS      & X_INDEX[]
                      # Y_INDEX_CS      & Y_INDEX[]
                      # DP_RAM_CS       & BL_HRAM_OUT[]
                      ,BLITTER_CS & !nFB_OE);                                   -- FFFF8A00-7F
--------------------------------------------------------------------------------------
-- SRC BUFFER LADEN
    BL_SRC_BUF1[].CLK = DDRCLK0;
    BL_SRC_BUF1[127..64].ENA = BLITTER_DACK1 & BL_READ_SRC;
    BL_SRC_BUF1[63..0].ENA   = BLITTER_DACK0 & BL_READ_SRC;
    BL_SRC_BUF1[] = (VDP_IN[],VDP_IN[]);
    BL_SRC_BUF2[].CLK = DDRCLK0;
    BL_SRC_BUF2[127..64].ENA = BLITTER_DACK1 & BL_READ_SRC;
    BL_SRC_BUF2[63..0].ENA   = BLITTER_DACK0 & BL_READ_SRC;
    BL_SRC_BUF2[] = BL_SRC_BUF1[];
    BL_SRC_BUF3[].CLK = DDRCLK0;
    BL_SRC_BUF3[127..64].ENA = BLITTER_DACK1 & BL_READ_SRC;
    BL_SRC_BUF3[63..0].ENA   = BLITTER_DACK0 & BL_READ_SRC;
    BL_SRC_BUF3[] = BL_SRC_BUF2[];
    -- ZUORDNUNG ---------------------------------------------------
    IF BL_SRC_X_INC15 THEN      -- WENN NEGATIV -> REIHENFOLGE KEHREN
        BL_BSIN[127..0]   = BL_SRC_BUF3[];
        BL_BSIN[255..128] = BL_SRC_BUF2[];
        BL_BSIN[383..256] = BL_SRC_BUF1[];
    ELSE                        -- SONST NORMAL BEI VORW�RTS
        BL_BSIN[127..0]   = BL_SRC_BUF1[];
        BL_BSIN[255..128] = BL_SRC_BUF2[];
        BL_BSIN[383..256] = BL_SRC_BUF3[];
    END IF;
-- DST BUFFER READ
    BL_DST_BUFRD[].CLK = DDRCLK0;
    BL_DST_BUFRD[127..64].ENA = BLITTER_DACK1 & BL_READ_DST;
    BL_DST_BUFRD[63..0].ENA   = BLITTER_DACK0 & BL_READ_DST;
    BL_DST_BUFRD[] = (VDP_IN[],VDP_IN[]);
-- barell shift *****************************************************************************
-- SOURCE SHIFT RIGHT = LPM_CSHIFT RIGTH ;SKEW SHIFT: IF FXRS==0 THEN RIGHT ELSE LEFT
    DIST_RIGHT[] = (16 * ((0,DST_ADR32[3..1]) - (0,SRC_ADR32[3..1]))) + (!BL_SKEW7 &  (0,BL_SKEW[3..0])) - (BL_SKEW7 & (0,BL_SKEW[3..0]));
    IF DIST_RIGHT8 THEN
        BS_SKEW[] = 0 - DIST_RIGHT[7..0];                   -- LPM SHIFT LEFT
        SHIFT_DIR = GND;                                    -- DIR = LEFT
    else
        BS_SKEW[] = DIST_RIGHT[7..0];                       -- LPM SHIFT RIGHT
        SHIFT_DIR = VCC;                                    -- DIR = RIGHT
    end if;
-- barell shifter: direction 0=links 1=rechts IN BEZUG AUF ausgabewert!
    BL_BSOUT[] = lpm_clshift384(BL_BSIN[], SHIFT_DIR , BS_SKEW[]);  -- wir brauchen 128bit
-- HOP ***************************************************************************************
    CASE BL_HOP[1..0] IS
        WHEN H"0" =>
                    --    12345678901234567890123456789012
            HOP_OUT[] = H"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";
        WHEN H"1" =>
            HOP_OUT[] = (BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[]);
        WHEN H"2" =>
            HOP_OUT[] = BL_BSOUT[255..128];
        WHEN OTHERS =>
            HOP_OUT[] = (BL_BSOUT[255..128] & (BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[],BL_HRAM_OUT[]));
    END CASE;
-- OP *****************************************************************************************
    CASE BL_OP[3..0] IS
        WHEN H"0" =>
            OP_OUT[] = H"0";
            SRC_READ = B"0";
        WHEN H"1" =>
            OP_OUT[] = HOP_OUT[] AND BL_DST_BUFRD[];
            SRC_READ = BL_HOP1;
        WHEN H"2" =>
            OP_OUT[] = HOP_OUT[] AND !BL_DST_BUFRD[];
            SRC_READ = BL_HOP1;
        WHEN H"3" =>
            OP_OUT[] = HOP_OUT[];
            SRC_READ = BL_HOP1;
        WHEN H"4" =>
            OP_OUT[] = !HOP_OUT[] AND BL_DST_BUFRD[];
            SRC_READ = BL_HOP1;
        WHEN H"5" =>
            OP_OUT[] = BL_DST_BUFRD[];
            SRC_READ = B"0";
        WHEN H"6" =>
            OP_OUT[] = HOP_OUT[] XOR BL_DST_BUFRD[];
            SRC_READ = BL_HOP1;
        WHEN H"7" =>
            OP_OUT[] = HOP_OUT[] OR BL_DST_BUFRD[];
            SRC_READ = BL_HOP1;
        WHEN H"8" =>
            OP_OUT[] = !HOP_OUT[] AND !BL_DST_BUFRD[];
            SRC_READ = BL_HOP1;
        WHEN H"9" =>
            OP_OUT[] = !HOP_OUT[] XOR BL_DST_BUFRD[];
            SRC_READ = BL_HOP1;
        WHEN H"A" =>
            OP_OUT[] = !BL_DST_BUFRD[];
            SRC_READ = B"0";
        WHEN H"B" =>
            OP_OUT[] = HOP_OUT[] OR !BL_DST_BUFRD[];
            SRC_READ = BL_HOP1;
        WHEN H"C" =>
            OP_OUT[] = !HOP_OUT[];
            SRC_READ = BL_HOP1;
        WHEN H"D" =>
            OP_OUT[] = !HOP_OUT[] OR BL_DST_BUFRD[];
            SRC_READ = BL_HOP1;
        WHEN H"E" =>
            OP_OUT[] = !HOP_OUT[] OR !BL_DST_BUFRD[];
            SRC_READ = BL_HOP1;
        WHEN OTHERS =>
                    --   12345678901234567890123456789012
            OP_OUT[] = H"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";
            SRC_READ = B"0";
    END CASE;
------------ ENDMASKEN SETZEN ******************************************************************************
            ENDMASK1_SHIFT[3..0] = 0;
            ENDMASK2_SHIFT[3..0] = 0;
            ENDMASKEND[] =  DST_ADR32[] + (0,(BL_X_CNT[] - X_INDEX[]) - 1) * DST_XINC32[];
            IF BL_DST_X_INC15 THEN ---------------------------- R�CKW�RTS X_INC NEGATIV
                IF X_INDEX[] == 0 THEN                                                          -- ENDE?
                    ENDMASK2_SHIFT[7..4] = 8 - (0,(DST_ADR32[3..1]));                           -- JA ENDMASK 3 SETZEN
                ELSE
                    ENDMASK2_SHIFT[7..4] = 0;                                                   -- NEIN -> ENDMASK 3 AUF ENDMASK2 SETZEN
                END IF;
                IF (X_CNT16[] + DST_X_INC[]) >= BL_X_CNT[] THEN                                 -- SCHON ZEILENENDE?
                    ENDMASK1_SHIFT[7..4] = 1 + (0,(ENDMASKEND[3..1]));                          -- JA -> ENDMASK 1 SETZEN
                ELSE
                    ENDMASK1_SHIFT[7..4] = 0;                                                   -- NEIN -> ENDMASK 3 AUF ENDMASK2 SETZEN
                END IF;
            ELSE    ------------------------------------------- VORW�RTS X_INC POSITIV (immer bei memcopy)
                IF X_INDEX[] == 0 THEN                                                          -- ANFANG?
                    ENDMASK1_SHIFT[7..4] = 1 + (0,(DST_ADR32[3..1]));                           -- JA -> ENDMASK 1 SETZEN
                ELSE
                    ENDMASK1_SHIFT[7..4] = 0;                                                   -- NEIN->ENDMASK1  AUF ENDMASK2 SETZEN
                END IF;
                IF (X_CNT16[] + DST_X_INC[]) >= BL_X_CNT[] THEN                                 -- SCHON ZEILENENDE?
                    ENDMASK2_SHIFT[7..4] = 8 - (0,(ENDMASKEND[3..1]));                          -- JA: ENDMASK 3 SETZEN
                ELSE
                    ENDMASK2_SHIFT[7..4] = 0;                                                   -- NOCH NICHT AKTIV->ENDMASK 3 AUF ENDMASK2 SETZEN
                END IF;
            END IF;
-- ENDMASKEN -- barell shifter 144 bit, direction 0 = links 1 = rechts
        BL_ENDMASK0[] = 0;
        BL_ENDMASKF[] = -1;
        BL_ENDMASKL[] = BL_ENDMASK1[] & !BL_DST_X_INC15 # BL_ENDMASK3[] & BL_DST_X_INC15;
        BL_ENDMASKR[] = BL_ENDMASK3[] & !BL_DST_X_INC15 # BL_ENDMASK1[] & BL_DST_X_INC15;
    CASE DST_X_INC[] IS
        WHEN 8 =>   -- INC 2
            ENDMASK12_IN[] = (BL_ENDMASKL[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[]);
            ENDMASKM_IN[]  =               (BL_ENDMASKF[],BL_ENDMASKF[],BL_ENDMASKF[],BL_ENDMASKF[],BL_ENDMASKF[],BL_ENDMASKF[],BL_ENDMASKF[],BL_ENDMASKF[]);
            ENDMASK23_IN[] =               (BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASKR[]);
        WHEN 4 =>   -- INC 4
            ENDMASK12_IN[] = (BL_ENDMASKL[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[]);
            ENDMASKM_IN[]  =               (BL_ENDMASKF[],BL_ENDMASK0[],BL_ENDMASKF[],BL_ENDMASK0[],BL_ENDMASKF[],BL_ENDMASK0[],BL_ENDMASKF[],BL_ENDMASK0[]);
            ENDMASK23_IN[] =               (BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASKR[]);
        WHEN 2 =>   -- INC 8
            ENDMASK12_IN[] = (BL_ENDMASKL[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[]);
            ENDMASKM_IN[]  =               (BL_ENDMASKF[],BL_ENDMASK0[],BL_ENDMASK0[],BL_ENDMASK0[],BL_ENDMASKF[],BL_ENDMASK0[],BL_ENDMASK0[],BL_ENDMASK0[]);
            ENDMASK23_IN[] =               (BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASKR[]);
        WHEN OTHERS =>
            ENDMASK12_IN[] = (BL_ENDMASKL[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[]);
            ENDMASKM_IN[]  =               (BL_ENDMASKF[],BL_ENDMASK0[],BL_ENDMASK0[],BL_ENDMASK0[],BL_ENDMASK0[],BL_ENDMASK0[],BL_ENDMASK0[],BL_ENDMASK0[]);
            ENDMASK23_IN[] =               (BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASK2[],BL_ENDMASKR[]);
    END CASE;
    ENDMASK12_OUT[] = lpm_clshift144(ENDMASK12_IN[],1,ENDMASK1_SHIFT[]);            -- IMMER rechts SCHIEBEN
    ENDMASK23_OUT[] = lpm_clshift144(ENDMASK23_IN[],0,ENDMASK2_SHIFT[]);            -- IMMER LINKS SCHIEBEN
    ROR_CNT[] = 16 * (0,DST_ADR32[3..1]);
    ENDMASKM_OUT[] = lpm_ror128(ENDMASKM_IN[],ROR_CNT[6..0]);
    ENDMASK123[].CLK = DDRCLK0;
    ENDMASK123[] = ENDMASK12_OUT[127..0] & ENDMASK23_OUT[143..16] & ENDMASKM_OUT[];
    BLITTER_DOUT[] = ((ENDMASK123[] & OP_OUT[]) # (!ENDMASK123[] & BL_DST_BUFRD[]));
    NOT_DST_READ = ((BL_OP[3..0] == H"0") # (BL_OP[3..0] == H"3") # (BL_OP[3..0] == H"C") # (BL_OP[3..0] == H"F")) & (ENDMASK123[] == H"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
-- STATE MACHINE **********************************************************************************---------------------------12345678901234567890123456789012
    BLITTER_RUN = BLITTER_ON;                                       -- BLITTER IST DA!
    BLITTER_ADR[3..0] = H"0";                                       -- IMMER LINE
    BLITTER_SIG.CLK = DDRCLK0;
    BLITTER_SIG = BLITTER_REQ & !BLITTER_DACK0 & !BLITTER_DACK1;
-- BLITTER MAIN STATE MACHINE  -----------------------------------------------
    BL_SM.CLK = DDRCLK0;
    SRC_OLD[].CLK = DDRCLK0;
    SRC_OLD[] = SRC_ADR32[31..4];
    SDXINC.CLK = DDRCLK0;
    CASE BL_SM IS
        WHEN START =>   ------------------------- START
            BL_NOTRUN = VCC;            -- BLITTER NOT RUN
            IF BLITTER_ON & BL_START & (BL_X_CNT[] > X_CNT16[]) & (BL_Y_CNT[] > Y_INDEX[]) THEN -- STARTEN?
                BL_SM = NEW_LINE;                                   -- JA START
            ELSE
                BL_SM = START;                                      -- NICHT STARTEN
            END IF;
        WHEN NEW_LINE => ----------------------- NEU LINIE
            X_INDEX_CLR_DIR = VCC;                                  -- JA -> X INDEX L�SCHEN F�R START LINE
            IF SRC_READ THEN                                        -- SOURCE READ N�TIG?
                BL_SM = RDSRC3;                                     -- JA
            ELSE
                BL_SM = RDDST;                                      -- NEIN -> DIREKT ZU READ DEST
            END IF;
        WHEN RDSRC3 =>  ------------------------ READ SRC3
            BLITTER_ADR[31..4] = SRC_ADR32[31..4] - 1 + (2 & BL_SRC_X_INC15);
            BLITTER_REQ = VCC;
            BL_READ_SRC = VCC;                              -- LATCH UND SB1->SB2
            IF BLITTER_DACK0 THEN
                BL_SM = RDSRC2;
            ELSE
                BL_SM = RDSRC3;
            END IF;
        WHEN RDSRC2 =>  ------------------------- READ SRC2
            BLITTER_ADR[31..4] = SRC_ADR32[31..4];
            BLITTER_REQ = VCC;
            BL_READ_SRC = VCC;                                  -- LATCH UND SB1->SB2
            IF BLITTER_DACK0 THEN
                BL_SM = RDSRC1;
            ELSE
                BL_SM = RDSRC2;
            END IF;
        WHEN RDSRC1 =>  ------------------------ READ SRC1
            BLITTER_ADR[31..4] = SRC_ADR32[31..4] + 1 - (2 & BL_SRC_X_INC15);
            BLITTER_REQ = VCC;
            BL_READ_SRC = VCC;                              -- LATCH UND SB1->SB2
            SRC_OLD[].ENA = VCC;
            IF BLITTER_DACK0 THEN
                BL_SM = RDDST;
            ELSE
                BL_SM = RDSRC1;
            END IF;
        WHEN RDDST =>   ------------------------ READ DEST
            BLITTER_ADR[31..4] = DST_ADR32[31..4];
            IF NOT_DST_READ THEN
                BL_SM = WRDSTW;
            ELSE
                BLITTER_REQ = VCC;
                BL_READ_DST = VCC;
                IF BLITTER_DACK0 THEN
                    BL_SM = WRDSTW;
                ELSE
                    BL_SM = RDDST;
                END IF;
            END IF;
        WHEN WRDSTW =>   ------------------------ KURZ WARTEN AUF ERGEBNIS
            BLITTER_ADR[31..4] = DST_ADR32[31..4];
            BL_SM = WRDST;
        WHEN WRDST =>   ------------------------- WRITE DEST
            BLITTER_ADR[31..4] = DST_ADR32[31..4];
            BLITTER_WR = VCC;
            BLITTER_REQ = VCC;
            SDXINC = BLITTER_DACK2;                                 -- INCCREMENT SRC, DST, X_INDEX
            IF BLITTER_DACK0 THEN
                BL_SM = TESTZEILENENDE;
            ELSE
                BL_SM = WRDST;
            END IF;
        WHEN TESTZEILENENDE =>  ----------------- ZEILENDE?
            IF X_CNT16[] >= BL_X_CNT[] THEN                         -- SCHON ZEILENENDE?
                YIINC = VCC;                                        -- JA -> INC Y-INDEX
                BL_SM = TESTFERTIG;                                 -- => TEST OB FERTIG
            ELSE
                IF !SRC_READ THEN                                   -- KEIN SOURCE READ?
                    BL_SM = RDDST;                                  -- JA => LESEN UNN�TIG ->
                ELSE
                    IF SRC_ADR32[31..4] == SRC_OLD[] THEN           -- ADRESSE IMMER NOCH IN DER LINE?
                        BL_SM = RDDST;                              -- DATEN SIND G�LTIG -> READ DEST
                    ELSE
                        BL_SM = RDSRC1;                             -- SONST NEXT SRC
                    END IF;
                END IF;
            END IF;
        WHEN TESTFERTIG =>  --------------------- TEST AUF FERTIG
            ZAINC = VCC;                                            -- ZEILENENDE: INC SRC UND DST ADRESSEN
            IF Y_INDEX[] >= BL_Y_CNT[] THEN                         -- LETZTE ZEILE?
                BL_SM = FERTIG;                                     -- JA => FERTIG
            ELSE
                BL_SM = NEW_LINE;                                   -- NEIN => NEXT LINE
            END IF;
        WHEN FERTIG => -------------------------- FERTIG
            BL_NOTRUN = VCC;                                        -- BLITTER NOT RUN
            BLITTER_INT = VCC;                                      -- BLITTER INTERRUPT
            LN7_CLR = VCC;                                          -- BUSY BIT L�SCHEN
            IF (BL_LN7 == 0) & (BL_START == 0) THEN         -- WARTEN BIS GEL�SCHT (SYNC MIT 33MHz)
                BL_SM = START;
            ELSE
                BL_SM = FERTIG;
            END IF;
        WHEN OTHERS =>
            BL_SM = FERTIG;
    END CASE;
END;

